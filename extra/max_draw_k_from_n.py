import numpy as np
import matplotlib.pyplot as plt
import math
import json


def draw_rayleigh(n, scale=1.0):
    return np.random.rayleigh(scale=scale, size=n)


def draw_normal(n, scale=1.0):
    return np.random.normal(scale=scale, size=n)


def draw_random(xs, k):
    return np.random.choice(xs, size=k, replace=False)


def stats_max(xs, k, trials=10, minimize=False):
    print("Running for stats max size", k, end="\r", flush=True)
    results = []
    for trial in range(trials):
        if not minimize:
            results.append(np.max(draw_random(xs, k)))
        else:
            results.append(np.min(draw_random(xs, k)))
    return results


def visualize_dist(dist, samples=None):
    fig, ax = plt.subplots(1, 2, figsize=(12, 6))
    ax[0].plot(np.sort(dist))
    ax[1].hist(dist, bins=400, density=True)

    plt.show()


def redwhite_index_old(dist, M):
    N = len(dist)

    reciprocal = math.comb(N, M)
    index = 0.0
    for i in range(M, N + 1):
        index += i * math.comb(i - 1, M - 1) / reciprocal

    index = round(index) - 1
    dist.sort()
    return dist[index]


def redwhite_index(dist, M, minimize=False):
    N = len(dist)
    print("Running for subset size", M, end="\r", flush=True)
    # index = (N+1)*(N+1-M)*math.comb(N, M-1) / math.comb(N, M) / (M+1)
    index = M * (N + 1) / (M + 1)
    # index = math.ceil(index)
    # index = math.floor(index)
    index = round(index)
    if not minimize:
        dist.sort()
    else:
        dist = np.sort(dist)[::-1]
    index = min(dist.shape[0] - 1, index)
    return dist[index]


def expected_trials(p, N):
    return p * N / (1 + (1 - p) * N)


def expected_trials_val(p, arr, minimize=True):
    arr.sort()
    N = arr.shape[0]
    if minimize:
        # Reverse cause minimization problem
        arr = arr[::-1]
        # Find index of first element in sorted list greater than the maximum
        # In case of x <= (1+p) * f_opt
        i = next(x[0] for x in enumerate(arr) if x[1] <= (1 + p) * arr[-1])
    else:
        # In case of p*x <= f_opt
        i = next(x[0] for x in enumerate(arr) if p * x[1] <= arr[-1])
    return int(math.ceil(i / (N + 1 - i)))


def get_indices(dist, draws):
    dist = np.array(dist)
    draws = np.array(draws)
    if draws.ndim == 1:
        indices_found = []
        for x in draws:
            indices = np.where(x == dist)[0]
            indices = round(np.mean(indices))
            indices_found.append(indices)
        # indices = np.concatenate([np.where(x == dist) for x in draws]).flatten()
    elif draws.ndim == 2:
        indices_found = []
        for y in draws:
            indices_per_trial = []
            for x in y:
                indices = np.where(x == dist)[0]
                indices = round(np.mean(indices))
                indices_per_trial.append(indices)
            indices_found.append(indices_per_trial)
        # indices = [np.concatenate([np.where(x == dist) for x in y]).flatten() for y in draws]
    else:
        raise Exception("Expected draws to be 1D or 2D")
    indices_found = np.array(indices_found)
    return indices_found


if __name__ == "__main__":
    # seed = 1234567
    # np.random.seed(seed)
    # random.seed(seed)

    # arr = np.load('obj_values.npy')
    # path = '../../old_cached_data_used/cache_files/pnpoly_RTX_2070_SUPER.json'
    # path = '../../old_cached_data_used/cache_files/GEMM_RTX_2070_SUPER.json'
    path = "../../cached_data_used/cachefiles/GEMM/RTX_2080_Ti.json"
    with open(path, "r") as myfile:
        data = myfile.read()
    data = json.loads(data)
    times = []
    for k in data["cache"].keys():
        time = data["cache"][k]["time"]
        times.append(time)
    dist = np.array(times)

    size = dist.shape[0]
    # Alle sample sizes k die ik ga proberen
    budgets = range(10, 600, 5)

    # size = 10000
    # Kies random rare distribution
    # dist = draw_rayleigh(size, scale=1.5)
    # dist = draw_normal(size, scale=5.5)

    # Dit is wat volgens mijn formule de expected index in het gesorteerde lijstje zou
    # moeten zijn voor elke k.
    draws = np.array([redwhite_index(dist, budget, minimize=True) for budget in budgets])
    dist = np.sort(dist)[::-1]

    # Ter verification voeren we het experiment ook uit door gewoon de Max() van budget
    # samples vaak te nemen.
    trials = 250
    results = np.array([stats_max(dist, budget, trials=trials, minimize=True) for budget in budgets])

    # Ter verification pakken we ook de gemiddelde resultaten van 500x Kernel Tuner Random Sampling
    kernel_tuner_random_sampling_results_mean_index = [
        13.524465948343277,
        13.251847922801971,
        13.04608404636383,
        12.940871983766556,
        12.847785115242004,
        12.791511923074722,
        12.76243406534195,
        12.739392966032028,
        12.721121042966843,
        12.711491972208023,
        12.702621042728424,
        12.686877012252808,
        12.681434035301208,
        12.672489017248154,
        12.667065024375916,
        12.656043946743011,
        12.654492974281311,
        12.648293942213058,
        12.644572973251343,
        12.63792598247528,
        12.633741080760956,
        12.631166994571686,
        12.62380102276802,
        12.623418003320694,
        12.622876107692719,
        12.617306977510452,
        12.614940971136093,
        12.600599020719528,
        12.600029945373535,
        12.599208980798721,
        12.595039010047913,
        12.592737972736359,
        12.592384934425354,
        12.590020954608917,
        12.587186008691788,
        12.58650803565979,
        12.582630962133408,
        12.570687979459763,
        12.570687979459763,
        12.568828016519547,
        12.562755048274994,
        12.562755048274994,
        12.562377989292145,
        12.558174967765808,
        12.552642077207565,
        12.551357120275497,
        12.551357120275497,
        12.547720909118652,
        12.547720909118652,
        12.546715945005417,
        12.542918920516968,
        12.541784077882767,
        12.537901014089584,
        12.537901014089584,
        12.537748038768768,
        12.537748038768768,
        12.537748038768768,
        12.537748038768768,
        12.53769600391388,
        12.53769600391388,
        12.53769600391388,
        12.536771923303604,
        12.536771923303604,
        12.536771923303604,
        12.536737978458405,
        12.527255028486252,
        12.527255028486252,
        12.52605801820755,
        12.524917036294937,
        12.524917036294937,
        12.510882079601288,
        12.510882079601288,
        12.510882079601288,
        12.510882079601288,
        12.506016969680786,
        12.506016969680786,
        12.506016969680786,
        12.506016969680786,
        12.506016969680786,
        12.490258932113647,
        12.490258932113647,
        12.490258932113647,
        12.488147914409637,
        12.488147914409637,
        12.488147914409637,
        12.488147914409637,
        12.483211010694504,
        12.483211010694504,
        12.483211010694504,
        12.483211010694504,
        12.483211010694504,
        12.483211010694504,
        12.483211010694504,
        12.477294027805328,
        12.477294027805328,
        12.477294027805328,
        12.477294027805328,
        12.477294027805328,
        12.477294027805328,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.464885950088501,
        12.464885950088501,
        12.464885950088501,
        12.464885950088501,
        12.464885950088501,
        12.464885950088501,
    ]
    kernel_tuner_random_sampling_results_mean = [
        13.519085302591323,
        13.233785908222199,
        13.043923412144185,
        12.943390118777751,
        12.864797320067883,
        12.80558346515894,
        12.775902754426003,
        12.739943987727166,
        12.71835961830616,
        12.698021166443825,
        12.680057615280152,
        12.669334626972676,
        12.656803318142892,
        12.642711073219775,
        12.634959172904491,
        12.625064936161042,
        12.619256985366345,
        12.609563342750073,
        12.605098694205283,
        12.598311011731624,
        12.592209540784358,
        12.583592520654202,
        12.578411861777306,
        12.575601720452308,
        12.57172705435753,
        12.568085751473903,
        12.563388852000237,
        12.55866426974535,
        12.55476011866331,
        12.55303332877159,
        12.548532082200051,
        12.545757007956505,
        12.543331994175912,
        12.54168305426836,
        12.537906733214855,
        12.53478366792202,
        12.531394877314568,
        12.527084139287473,
        12.525398623228073,
        12.522180352032185,
        12.519158595383168,
        12.516618405640125,
        12.514235684990883,
        12.51218471968174,
        12.509602867841721,
        12.507510809719562,
        12.506946569561958,
        12.50477125710249,
        12.503060741245747,
        12.500204107046127,
        12.497732355237007,
        12.49536386114359,
        12.49339423495531,
        12.491565481305122,
        12.490633376896382,
        12.489836717009544,
        12.488838727414608,
        12.487059986889362,
        12.485036224782467,
        12.484821373224259,
        12.482970317184925,
        12.482114167630673,
        12.480926637768745,
        12.480484101176263,
        12.478246002674103,
        12.474869371771813,
        12.47327060931921,
        12.470855392992496,
        12.469559332907199,
        12.468221702456475,
        12.466463716328144,
        12.464973404228687,
        12.464162098050117,
        12.463426448106766,
        12.462010557651519,
        12.461191633105278,
        12.460802951037884,
        12.460022441267967,
        12.45849232161045,
        12.457968731582165,
        12.456761771559716,
        12.455291309177875,
        12.454361337602139,
        12.453522969305515,
        12.45244143486023,
        12.451057874381542,
        12.450354830682278,
        12.449548534572125,
        12.447856379926204,
        12.447195244014264,
        12.446607715845108,
        12.445627521634101,
        12.445107019662856,
        12.444385385394096,
        12.443810849428177,
        12.442699117422103,
        12.44240766966343,
        12.441644605278968,
        12.440029987931252,
        12.439219269752503,
        12.437023292839527,
        12.436232662677766,
        12.435696800410748,
        12.434520457863808,
        12.433916415452957,
        12.43336732339859,
        12.433131937205792,
        12.432534361302853,
        12.432364911079407,
        12.43077593100071,
        12.429745472729206,
        12.429467700719833,
        12.428771956264972,
        12.42831790816784,
        12.427048825979233,
        12.42681841826439,
        12.42588206243515,
        12.425556254327297,
    ]
    kernel_tuner_random_sampling_results_median = [
        13.256847023963928,
        13.0001620054245,
        12.838474497199059,
        12.784044072031975,
        12.734955996274948,
        12.718577027320862,
        12.711612954735756,
        12.697094485163689,
        12.67992453277111,
        12.660316973924637,
        12.650339990854263,
        12.643484055995941,
        12.636503040790558,
        12.633056968450546,
        12.631629511713982,
        12.624862492084503,
        12.623418003320694,
        12.617443025112152,
        12.614940971136093,
        12.601837992668152,
        12.599619463086128,
        12.59341050684452,
        12.592561453580856,
        12.591202944517136,
        12.589121043682098,
        12.585728913545609,
        12.584179937839508,
        12.569757997989655,
        12.567519024014473,
        12.5662100315094,
        12.562377989292145,
        12.560276478528976,
        12.558174967765808,
        12.558174967765808,
        12.552642077207565,
        12.551357120275497,
        12.547218427062035,
        12.542351499199867,
        12.539842545986176,
        12.537748038768768,
        12.536771923303604,
        12.536737978458405,
        12.527255028486252,
        12.527255028486252,
        12.526656523346901,
        12.52605801820755,
        12.524917036294937,
        12.524917036294937,
        12.524917036294937,
        12.510882079601288,
        12.510882079601288,
        12.510882079601288,
        12.508449524641037,
        12.506016969680786,
        12.506016969680786,
        12.506016969680786,
        12.506016969680786,
        12.490258932113647,
        12.488147914409637,
        12.488147914409637,
        12.488147914409637,
        12.488147914409637,
        12.483211010694504,
        12.483211010694504,
        12.483211010694504,
        12.477294027805328,
        12.477294027805328,
        12.477294027805328,
        12.477294027805328,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.464885950088501,
        12.464885950088501,
        12.464885950088501,
        12.462632939219475,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.455189943313599,
        12.455189943313599,
        12.455189943313599,
        12.455189943313599,
        12.455189943313599,
        12.455189943313599,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
    ]
    kernel_tuner_random_sampling_results_median_index = [
        13.25556805729866,
        13.000701993703842,
        12.838758945465088,
        12.783767998218536,
        12.735361993312836,
        12.718577027320862,
        12.711733937263489,
        12.699859023094177,
        12.680144101381302,
        12.660366922616959,
        12.650339990854263,
        12.643484055995941,
        12.635080099105835,
        12.633056968450546,
        12.632092028856277,
        12.62380102276802,
        12.623418003320694,
        12.617443025112152,
        12.614940971136093,
        12.601837992668152,
        12.599208980798721,
        12.592737972736359,
        12.592737972736359,
        12.590020954608917,
        12.589121043682098,
        12.585728913545609,
        12.585728913545609,
        12.568828016519547,
        12.568828016519547,
        12.5662100315094,
        12.562377989292145,
        12.558174967765808,
        12.558174967765808,
        12.558174967765808,
        12.552642077207565,
        12.551357120275497,
        12.546715945005417,
        12.541784077882767,
        12.541784077882767,
        12.537748038768768,
        12.536771923303604,
        12.536737978458405,
        12.527255028486252,
        12.527255028486252,
        12.527255028486252,
        12.52605801820755,
        12.524917036294937,
        12.524917036294937,
        12.524917036294937,
        12.510882079601288,
        12.510882079601288,
        12.510882079601288,
        12.506016969680786,
        12.506016969680786,
        12.506016969680786,
        12.506016969680786,
        12.506016969680786,
        12.490258932113647,
        12.488147914409637,
        12.488147914409637,
        12.488147914409637,
        12.488147914409637,
        12.483211010694504,
        12.483211010694504,
        12.483211010694504,
        12.477294027805328,
        12.477294027805328,
        12.477294027805328,
        12.477294027805328,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.475106984376907,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.468926966190338,
        12.464885950088501,
        12.464885950088501,
        12.464885950088501,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.460379928350449,
        12.455189943313599,
        12.455189943313599,
        12.455189943313599,
        12.455189943313599,
        12.455189943313599,
        12.455189943313599,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.4251129925251,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
        12.421824008226395,
    ]

    val_indices = get_indices(dist, results)
    draw_indices = get_indices(dist, draws)

    # Find the mean index per list of trial runs per function evaluation.
    mean_indices = [round(x) for x in val_indices.mean(axis=1)]
    val_results_index_mean = dist[mean_indices]

    # vvv Foute plot
    locs = results.mean(axis=1)
    locs = np.median(results, axis=1)  # <-- median is logischer
    stdevs = results.std(axis=1)

    def plot_wrong():
        # plt.errorbar(np.array(budgets), locs, stdevs, color='blue', label="mean of random draws")
        plt.plot(np.array(budgets), locs, color="blue", label="mean of random draws")
        plt.plot(np.array(budgets), draws, color="red", label="expected best runtime based on index")
        plt.plot(
            np.array(budgets),
            kernel_tuner_random_sampling_results_mean,
            color="green",
            label="kernel tuner random sampling (mean)",
        )
        plt.plot(
            np.array(budgets),
            kernel_tuner_random_sampling_results_mean_index,
            color="orange",
            label="kernel tuner random sampling (mean of index)",
        )
        plt.title("'Wrong' plot")
        # plt.title(" (red)\n not the same as mean of random draws", size=14)
        plt.legend()
        plt.show()

    def plot_correct():
        plt.plot(np.array(budgets), val_results_index_mean, color="blue", label="runtime of mean index measured")
        plt.plot(np.array(budgets), draws, color="red", label="expected best runtime per budget")
        plt.plot(
            np.array(budgets),
            kernel_tuner_random_sampling_results_mean,
            color="green",
            label="kernel tuner random sampling (mean)",
        )
        plt.plot(
            np.array(budgets),
            kernel_tuner_random_sampling_results_mean_index,
            color="orange",
            label="kernel tuner random sampling (mean of index)",
        )
        plt.title("'Correct' plot")
        # plt.title(" (red)\n vs runtime of mean index measured (blue)", size=14)
        plt.legend()
        plt.show()

    def plot_indices():
        # vvv Index plot wanneer het wel goed gaat
        plt.errorbar(
            np.array(budgets),
            val_indices.mean(axis=1),
            val_indices.std(axis=1),
            color="blue",
            label="measured mean index found",
        )
        plt.plot(np.array(budgets), draw_indices, color="red", label="expected index per budget")
        plt.title("Expected index per budget (red)\n vs measured mean index found (blue)", size=14)
        plt.legend()
        plt.show()

    plot_wrong()
    # plot_indices()
    plot_correct()
